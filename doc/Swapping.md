## Swapping

Since seL4 does not provide a native support for refernece bit, in order to implement a second chance page replacement  algorithm, we have to deal with the memory reference ourselves. To achieve this, whenever swapping is triggered, we will iterate through the frame tables, unmap the frame from the page table and clear the reference bit in the frame table until we reach a frame without reference bit set. In the page fault handler, the reference bit will be set when we map a frame for the process. Besides, seL4 does not tell the type of a page fault as well. Consequently, we have to do something to help us to figure out what triggers a page fault, whether it is a page that has been swapped out, a page gets unmapped due to second chance simulating process or a page that has not been allocated yet. A present bit and unmapping bit are added in the page table, which tells us whether that page is in the swapping file or is still in memory. If the present bit is not set, then we have to load that page from swapping file. Otherwise, we only need to remap that page. 

How to manage the swapping file is another design choice and we choose to keep our design simple enough though it do have performance issue. Our swapping file is to some extent like our frame table. Its free slot is chained together and we store the next free slot inside the swapping file itself. We only store the first free slot in memory and when we need to swap a page, we have to first read the next free slot from the swapping file and replace our in-memory first free slot with this new value and then dump the page to the swpping file at the offset determined by the previous first free slot. By doing so, we do not need to keep the whole free list in memory and add more overhead to page table and frame table. However, it does slow down the swapping process. It is a tradeoff and we choose to keep it simple and easier to handle.

It is obvious that swapping file is a shared resource and we use a swp_lock to make sure at any given time, only one process will have access to the swapping file. At first glance, it seems unnecessary to add such lock since we use coroutine. However, since each time we have to write the free slot as well as the page itself. Atomicity should be preserved or the chian might get broken and in a even worse situation, load page will read some junk and crash the process. Such mechanism will also have a negative impact on the performance cause when thrahing occurs, lock contention will become severe.